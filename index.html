<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Babylon XR Test</title>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://preview.babylonjs.com/babylon.max.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src=https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js></script>
</head>

<body>

<canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

<script type="module">
  var canvas = document.getElementById("renderCanvas"); // Get the canvas element
  var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

  // let polyfill = new WebXRPolyfill();
  if (!navigator.xr) {
    alert('no xr');
    throw Error('not supported');
  }

  var createScene = async function () {

    // Create scene
    var scene = new BABYLON.Scene(engine);
    // var env = scene.createDefaultEnvironment({enableGroundShadow: true, groundYBias: 1});
    // env.setMainColor(BABYLON.Color3.FromHexString("#010002"))

    // here we add XR support
    const xr = await scene.createDefaultXRExperienceAsync({
      // floorMeshes: [ground],
      uiOptions: {
        sessionMode: 'immersive-vr'
      }
    });
    if (!xr.baseExperience) {
      alert("No XR support");
    } else {
      console.log("XR supported");
    }

    const webXRInput = xr.input; // if using the experience helper, otherwise, an instance of WebXRInput
    webXRInput.onControllerAddedObservable.add((xrController /* WebXRInputSource instance */) => {
      // more fun with the new controller, since we are in XR!
      console.log(xrController);
      xrController.onMotionControllerInitObservable.add((motionController) => {
        // get the motionController, which is similar to but NOT a gamepad:
        console.log(motionController);
      });
      // xr supports all types of inputs, so some won't have a motion controller
      if (!xrController.gamepad) {
        // using touch, hands, gaze, something else?
      }
    });

    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -100), scene);
    camera.setTarget(new BABYLON.Vector3(0, 0, -1000));
    camera.attachControl(canvas, true);

    // var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    // light.intensity = 0.7;

    const frameRate = 30;
    const originalMaxTime = 3;
    const playbackSpeed = 0.5;
    const distanceConversion = 10;
    const discretization = 10;
    const heightBias = -1 * discretization;

    const x = [0.00,-0.00,-0.01,-0.03,-0.05,-0.09,-0.13,-0.18,-0.25,-0.34,-0.45,-0.59,-0.75,-0.95,-1.19,-1.47,-1.80,-2.17,-2.59,-3.06,-3.57,-3.92,-3.92,-3.92,-3.92,-3.92,-3.92,-3.92];
    const y = [1.00,0.99,0.97,0.96,0.97,1.00,1.05,1.10,1.17,1.23,1.28,1.33,1.36,1.36,1.33,1.27,1.17,1.02,0.82,0.56,0.24,-0.00,-0.00,-0.00,-0.00,-0.00,-0.00,-0.00];
    const z = [0.00,1.05,2.07,3.05,4.00,4.91,5.78,6.61,7.40,8.15,8.87,9.54,10.18,10.78,11.35,11.87,12.35,12.79,13.17,13.49,13.74,13.85,13.85,13.85,13.85,13.85,13.85,13.85];
    const alpha_x = [0.00,-0.08,-0.14,-0.20,-0.26,-0.31,-0.35,-0.40,-0.44,-0.48,-0.51,-0.55,-0.58,-0.62,-0.66,-0.69,-0.74,-0.78,-0.82,-0.86,-0.90,-0.92,-0.92,-0.92,-0.92,-0.92,-0.92,-0.92];
    const alpha_y = [0.00,-5.37,-10.73,-16.08,-21.43,-26.76,-32.09,-37.41,-42.72,-48.03,-53.33,-58.63,-63.92,-69.21,-74.50,-79.79,-85.07,-90.37,-95.67,-100.97,-106.29,-109.67,-109.67,-109.67,-109.67,-109.67,-109.67,-109.67];
    const alpha_z = [0.10,0.06,0.05,0.05,0.06,0.08,0.10,0.13,0.16,0.19,0.22,0.25,0.29,0.32,0.35,0.38,0.40,0.41,0.41,0.39,0.35,0.32,0.32,0.32,0.32,0.32,0.32,0.32];

    function toPositionFrames(points, bias) {
      bias = bias || 0;
      return points.map((p, i) => ({
        frame: i * frameRate / discretization / playbackSpeed,
        value: p * distanceConversion + bias
      }));
    }

    function toRotationFrames(points) {
      return points.map((p, i) => ({
        frame: i * frameRate / discretization / playbackSpeed,
        value: p
      }));
    }

    // createParticles(scene);

    var assetsManager = new BABYLON.AssetsManager(scene);
    const landscapeTask = assetsManager.addMeshTask("landscape", "", "barcelona/", "scene.gltf");
    landscapeTask.onSuccess = task => {
      const landscape = task.loadedMeshes[0];
      landscape.rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);
    };

    const task = assetsManager.addMeshTask("task2", "", "ultimate_frisbee/", "scene.gltf");
    task.onSuccess = task => {
      const frisbee = task.loadedMeshes[0];
      frisbee.position = new BABYLON.Vector3(0, 1, 0);
      frisbee.rotation = new BABYLON.Vector3(0, 0, 0);
      frisbee.scaling = new BABYLON.Vector3(0.0001, 0.0001, 0.0001);

      const material = new BABYLON.StandardMaterial("frisbee", scene);
      material.diffuseColor = new BABYLON.Color3(0, 0, 0);
      material.specularColor = new BABYLON.Color3(0.5, 0.6, 0.87);
      material.emissiveColor = new BABYLON.Color3(1, 0, 1);
      material.ambientColor = new BABYLON.Color3(0.23, 0.98, 0.53);
      frisbee.getChildMeshes(false, c => c.id === 'TARELKA_Mat.1_0')[0].material = material;

      try {
        const velocityCorrection = 1
        const xSlide = new BABYLON.Animation("translateX", "position.x", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        const ySlide = new BABYLON.Animation("translateY", "position.y", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        const zSlide = new BABYLON.Animation("translateZ", "position.z", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        xSlide.setKeys(toPositionFrames(x));
        ySlide.setKeys(toPositionFrames(y, heightBias));
        zSlide.setKeys(toPositionFrames(z));
        const xRot = new BABYLON.Animation("xRot", "rotation.x", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        const yRot = new BABYLON.Animation("yRot", "rotation.y", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        const zRot = new BABYLON.Animation("zRot", "rotation.z", frameRate * velocityCorrection, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        xRot.setKeys(toRotationFrames(alpha_x));
        yRot.setKeys(toRotationFrames(alpha_y));
        zRot.setKeys(toRotationFrames(alpha_z));
        scene.beginDirectAnimation(frisbee, [xSlide, zSlide, ySlide, xRot, yRot, zRot], 0, originalMaxTime / playbackSpeed * frameRate - frameRate , true);

        createParticles(scene, frisbee);
      } catch (e) {
        console.log(e);
      }
    }
    assetsManager.load();

    return scene;
  };

  function createParticles(scene, emitter) {
    var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
    particleSystem.emitter = emitter;
    particleSystem.particleTexture = new BABYLON.Texture("flare.png", scene);

    particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
    particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

    particleSystem.minSize = 0.2;
    particleSystem.maxSize = 0.5;

    // Life time of each particle (random between...
    particleSystem.minLifeTime = 0.3;
    particleSystem.maxLifeTime = 2;

    // Emission rate
    particleSystem.emitRate = 5500;

    // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Set the gravity of all particles
    particleSystem.gravity = new BABYLON.Vector3(5, -9.81, 0);

    // Direction of each particle after it has been emitted
    particleSystem.direction1 = new BABYLON.Vector3(-1000, -1000, -100);
    particleSystem.direction2 = new BABYLON.Vector3(1000, 1000, 100);

    // Angular speed, in radians
    particleSystem.minAngularSpeed = -Math.PI;
    particleSystem.maxAngularSpeed = Math.PI / 2;

    // Speed
    particleSystem.minEmitPower = 10;
    particleSystem.maxEmitPower = 20;
    particleSystem.updateSpeed = 0.005;

    // Start the particle system
    particleSystem.start();
  }

  var scenePromise = createScene(); //Call the createScene function

  engine.runRenderLoop(async function () {
    const scene = await scenePromise;
    scene.render();
  });

  window.addEventListener("resize", function () {
    engine.resize();
  });

  // scenePromise.then(scene => {
  //   scene.debugLayer.show({
  //     overlay: false
  //   });
  // });
</script>

</body>

</html>
