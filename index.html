<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Babylon XR Test</title>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://preview.babylonjs.com/babylon.max.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src=https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js></script>
</head>

<body>

<canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

<script type="module">
  var canvas = document.getElementById("renderCanvas"); // Get the canvas element
  var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

  // let polyfill = new WebXRPolyfill();
  if (!navigator.xr) {
    alert('no xr');
    throw Error('not supported');
  }

  var createScene = async function () {

    // Create scene
    var scene = new BABYLON.Scene(engine);
    // var env = scene.createDefaultEnvironment({enableGroundShadow: true, groundYBias: 1});
    // env.setMainColor(BABYLON.Color3.FromHexString("#010002"))

    // here we add XR support
    const xr = await scene.createDefaultXRExperienceAsync({
      // floorMeshes: [ground],
      uiOptions: {
        sessionMode: 'immersive-vr'
      }
    });
    if (!xr.baseExperience) {
      alert("No XR support");
    } else {
      console.log("XR supported");
    }

    const webXRInput = xr.input; // if using the experience helper, otherwise, an instance of WebXRInput
    webXRInput.onControllerAddedObservable.add((xrController /* WebXRInputSource instance */) => {
      // more fun with the new controller, since we are in XR!
      console.log(xrController);
      xrController.onMotionControllerInitObservable.add((motionController) => {
        // get the motionController, which is similar to but NOT a gamepad:
        console.log(motionController);
      });
      // xr supports all types of inputs, so some won't have a motion controller
      if (!xrController.gamepad) {
        // using touch, hands, gaze, something else?
      }
    });

    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -100), scene);
    camera.setTarget(new BABYLON.Vector3(0, 0, -1000));
    camera.attachControl(canvas, true);

    // var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    // light.intensity = 0.7;

    const frameRate = 30;

    createParticles(scene);

    var assetsManager = new BABYLON.AssetsManager(scene);
    const landscapeTask = assetsManager.addMeshTask("landscape", "", "barcelona/", "scene.gltf");
    landscapeTask.onSuccess = task => {
      const landscape = task.loadedMeshes[0];
      landscape.rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);
    };

    const task = assetsManager.addMeshTask("task2", "", "ultimate_frisbee/", "scene.gltf");
    task.onSuccess = task => {
      const frisbee = task.loadedMeshes[0];
      frisbee.position = new BABYLON.Vector3(1, 1, 2);
      frisbee.rotation = new BABYLON.Vector3(0, 0, 0);
      frisbee.scaling = new BABYLON.Vector3(0.0001, 0.0001, 0.0001);

      const material = new BABYLON.StandardMaterial("frisbee", scene);
      material.diffuseColor = new BABYLON.Color3(0, 0, 0);
      material.specularColor = new BABYLON.Color3(0.5, 0.6, 0.87);
      material.emissiveColor = new BABYLON.Color3(1, 0, 1);
      material.ambientColor = new BABYLON.Color3(0.23, 0.98, 0.53);
      frisbee.getChildMeshes(false, c => c.id === 'TARELKA_Mat.1_0')[0].material = material;

      try {
        const xSlide = new BABYLON.Animation("translate", "position.z", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        xSlide.setKeys([
          {frame: 0, value: 2},
          {frame: 2 * frameRate, value: 50}
        ]);
        const yRot = new BABYLON.Animation("yRot", "rotation.y", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        yRot.setKeys([
          {frame: 0, value: 0},
          {frame: frameRate, value: Math.PI},
          {frame: frameRate * 2, value: Math.PI * 2}
        ]);
        scene.beginDirectAnimation(frisbee, [xSlide, yRot], 0, 2 * frameRate, true);

        createParticles(scene, frisbee);
      } catch (e) {
        console.log(e);
      }
    }
    assetsManager.load();

    return scene;
  };

  function createParticles(scene, emitter) {
    var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
    particleSystem.emitter = emitter;
    particleSystem.particleTexture = new BABYLON.Texture("flare.png", scene);

    particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
    particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

    particleSystem.minSize = 0.2;
    particleSystem.maxSize = 0.5;

    // Life time of each particle (random between...
    particleSystem.minLifeTime = 0.3;
    particleSystem.maxLifeTime = 2;

    // Emission rate
    particleSystem.emitRate = 5500;

    // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Set the gravity of all particles
    particleSystem.gravity = new BABYLON.Vector3(5, -9.81, 0);

    // Direction of each particle after it has been emitted
    particleSystem.direction1 = new BABYLON.Vector3(-1000, -1000, -100);
    particleSystem.direction2 = new BABYLON.Vector3(1000, 1000, 100);

    // Angular speed, in radians
    particleSystem.minAngularSpeed = -Math.PI;
    particleSystem.maxAngularSpeed = Math.PI / 2;

    // Speed
    particleSystem.minEmitPower = 10;
    particleSystem.maxEmitPower = 20;
    particleSystem.updateSpeed = 0.005;

    // Start the particle system
    particleSystem.start();
  }

  var scenePromise = createScene(); //Call the createScene function

  engine.runRenderLoop(async function () {
    const scene = await scenePromise;
    scene.render();
  });

  window.addEventListener("resize", function () {
    engine.resize();
  });

  scenePromise.then(scene => {
    scene.debugLayer.show({
      overlay: false
    });
  });
</script>

</body>

</html>
